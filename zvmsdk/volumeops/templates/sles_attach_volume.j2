#!/bin/bash
# Generated by jinja2 template
fcp_list="{{ fcp_list }}"
input_wwpns="{{ wwpns }}"
lun="{{ lun }}"
target_filename="{{ target_filename }}"

echo "Enter SLES attach script with parameters: FCP list:${fcp_list[@]}, INPUT WWPNS:${input_wwpns[@]}, LUN:$lun, target_filename:$target_filename"

# because jinja2's problem, we can not use # to count the array_size
fcp_count=0
for fcp in ${fcp_list[@]}
do
    echo "fcp: $fcp"
    fcp_count=$((fcp_count+=1))
done

if [[ $fcp_count -eq 0 ]]; then
    echo "fcp_list is empty, exit with code 2."
    exit 2
fi

# see if zfcp is enable
enable_zfcp_mod=`lsmod | grep zfcp`
if [ -z "$enable_zfcp_mod" ];then
    modprobe zfcp
else
    echo "zfcp mode is already enabled"
fi

# online fcp devices
for fcp in ${fcp_list[@]}
do
    echo "online fcp $fcp"
    /sbin/cio_ignore -r $fcp > /dev/null
    /sbin/chccwdev -e $fcp > /dev/null
done

# send an iSCSI scan request with given host and optionally the ctl 
# the ctl means, c: channel,default to -
#                t: target, default to -
#                l: lun, default to -
all_hosts=(`ls /sys/class/scsi_host/`)
for host in ${all_hosts[@]}
do
    echo "- - -" > /sys/class/scsi_host/$host/scan
    echo "scan request to host $host sent."
done

# the number WWPNs is generated dynamically
# so we need to get them from the filesystem
# and get the intersection between input wwpns and lszfcp output
lszfcp_output=`lszfcp -P | awk '{print $1}' | awk -F'/' '{print $1,$2}'`
echo "lszfcp output port info: $lszfcp_output ."
declare -A valid_dict
for fcp in ${fcp_list[@]}
do
    for wwpn in ${input_wwpns[@]}
    do
        fcp_wwpn_str="0.0.${fcp} ${wwpn}"
        if [[ $lszfcp_output =~ $fcp_wwpn_str ]]; then
            # add this combination into valid_dict
            if [[ -z ${valid_dict[$fcp]} ]]; then
                valid_dict+=([$fcp]="$wwpn")
            else
                old_value=${valid_dict[$fcp]}
                new_value=${old_value}" "$wwpn
                valid_dict[$fcp]=$new_value
            fi
        fi
    done
done
echo "Got valid wwpns, list of key is: ${!valid_dict[@]}, list of value is: ${valid_dict[@]} ."

# check the content of valid_dict, if no content, return error
valid_fcp_count=0
for fcp in ${!valid_dict[@]}
do
    valid_fcp_count=$((valid_fcp_count+=1))
done
if [[ $valid_fcp_count -eq 0 ]]; then
    echo "valid_dict is empty, exit with code 2."
    exit 2
fi

# flag which indicate whether we found a valid and accessable path for the volume
FoundDiskPath=0
# wait for the device ready
for fcp in ${!valid_dict[@]}
do
    ActiveWWPNs=(${valid_dict[$fcp]})
    echo "Got WWPNs: ${ActiveWWPNs[@]} for FCP device: $fcp"
    
    # If auto-discovery of LUNs is disabled on s390 platforms
    # luns need to be added to the configuration through
    # the unit_add interface
    AutoScan=`cat /sys/module/zfcp/parameters/allow_lun_scan`
    if [[ "$AutoScan" != "Y" ]]; then
        for wwpn in ${ActiveWWPNs[@]}
        do
            chzdev -e -a zfcp-lun 0.0.$fcp:$wwpn:$lun
        done
    fi

    # in SLES, system dont need this file
    # but we need it when detach volume
    for wwpn in ${ActiveWWPNs[@]}
    do
        echo "0.0.$fcp $wwpn $lun" >> /etc/zfcp_ports.info
    done

    # create udev rules
    sleep 1
    touch /etc/udev/rules.d/51-zfcp-0.0.$fcp.rules
    out=`cat "/etc/udev/rules.d/51-zfcp-0.0.$fcp.rules" | egrep -i "ccw/0.0.$fcp]online"`
    if [[ ! $out ]]; then
      echo "ACTION==\"add\", SUBSYSTEM==\"ccw\", KERNEL==\"0.0.$fcp\", IMPORT{program}=\"collect 0.0.$fcp %k 0.0.$fcp zfcp\""| tee -a /etc/udev/rules.d/51-zfcp-0.0.$fcp.rules
      echo "ACTION==\"add\", SUBSYSTEM==\"drivers\", KERNEL==\"zfcp\", IMPORT{program}=\"collect 0.0.$fcp %k 0.0.$fcp zfcp\""| tee -a /etc/udev/rules.d/51-zfcp-0.0.$fcp.rules
      echo "ACTION==\"add\", ENV{COLLECT_0.0.$fcp}==\"0\", ATTR{[ccw/0.0.$fcp]online}=\"1\""| tee -a /etc/udev/rules.d/51-zfcp-0.0.$fcp.rules
    fi
    for wwpn in ${ActiveWWPNs[@]}
    do
        echo "ACTION==\"add\", KERNEL==\"rport-*\", ATTR{port_name}==\"$wwpn\", SUBSYSTEMS==\"ccw\", KERNELS==\"0.0.$fcp\",ATTR{[ccw/0.0.$fcp]$wwpn/unit_add}=\"$lun\""| tee -a /etc/udev/rules.d/51-zfcp-0.0.$fcp.rules
    done
    if [[ $(which udevadm 2> /dev/null) != '' ]]; then
        udevadm settle
    else
        udevsettle
    fi

    # wait for the devices ready
    # timeout set to 10 seconds
    Timeout=10
    while [ $FoundDiskPath -eq 0 ]
    do
        # if timeout less or equal 0 seconds, means no time left
        if [ $Timeout -le 0 ]; then
            echo "waiting for devices ready timed out after 10 seconds."
            break
        fi

        # loop all the WWPNs to found the alive device
        for j in ${ActiveWWPNs[@]}
        do
            x="/dev/disk/by-path/ccw-0.0.$fcp-zfcp-$j:$lun"
            # the x would be like:
            # ccw-0.0.1d13-zfcp-0x5005076306035388:0x4014400400000000
            echo "try disk path:$x"
            if [ -e $x ]; then
                diskPath=$x
                FoundDiskPath=1
                echo "Found disk path is: $diskPath"
                break
            fi
        done
        # if devices still not ready, wait another 5 seconds and retry
        if [ $FoundDiskPath -eq 0 ]; then
            sleep 1
            Timeout=$((Timeout-=1))
            echo "sleep 1 second to wait the devices ready, timeout left: $Timeout"
        fi
    done
done

if [ $FoundDiskPath -eq 1 ]; then
    echo "The storage device is ready and found disk path: $diskPath."
else
    echo "error happens during attachment because the device file of $fcp not found, will exit with code 1."
    exit 1
fi

# ensure multipathd service is up
enable_multipath_mod=`lsmod | grep dm_multipath`
if [ -z "$enable_multipath_mod" ];then
    modprobe dm-multipath
    echo -e "#blacklist {
    #   devnode \"*\"
    #}
    " > /etc/multipath.conf
    mpathconf
    systemctl restart multipathd.service
else
    echo "dm-multipath mode is already enabled"
fi

WWID=`/lib/udev/scsi_id --page 0x83 --whitelisted $diskPath`
echo "scsi_id command get WWID:$WWID for device $diskPath."

ConfigLib="/lib/udev/rules.d/56-zfcp.rules"
if [ -e "$ConfigLib" ]
then
    ConfigFile="/lib/udev/rules.d/56-zfcp.rules"
else
    ConfigFile="/etc/udev/rules.d/56-zfcp.rules"
fi

LinkItem="KERNEL==\"dm-*\", ENV{DM_UUID}==\"mpath-$WWID\", SYMLINK+=\"$target_filename\""
echo -e $LinkItem >> $ConfigFile

udevadm control --reload
udevadm trigger --sysname-match=dm-*

exit 0

